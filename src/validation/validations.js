import { ValidationError } from "../core/validationError";
import { PRIORITY, STATUS, VALIDATION_ERROR_CODES } from "../modules/constants";
import { isFutureDate, isValidDate } from "../utils/dateUtils";

const PRIMITIVE_TYPES = new Set([String, Number, Boolean, Symbol, BigInt]);

/**
 * Checks if field is instance of type
 * @param {any} field 
 * @param {Function} type 
 * @returns {Boolean}
 */
const isInstanceOf = (field, type) => {
    if (field === null || field === undefined) return false;

    if (PRIMITIVE_TYPES.has(type)) {
        return typeof field === type.name.toLowerCase();
    }

    return field instanceof type;
};

/**
 * Validates a target is of certain type
 * @param {any} field 
 * @param {Function} expectedType 
 * @throws {ValidationError}
 */
const validateType = (field, expectedType, details) => {
    if (!isInstanceOf(field, expectedType)) {
        throw new ValidationError(
            `Invalid type: expected ${expectedType.name}.`, 
            {
                code: VALIDATION_ERROR_CODES.INVALID_TYPE,
                ...details,
            }
        );
    }
};

/**
 * Validates text:
 * 1. Not empty
 * 2. Not too long
 * @param {String} text 
 * @param {Number} maxLength 
 * @param {String} field
 * @throws {ValidationError}
 */
const validateText = (text, maxLength, field) => {
    if (text.trim() === '') {
        throw new ValidationError(
            `${field} cannot be empty.`,
            {
                code: VALIDATION_ERROR_CODES.EMPTY_TEXT,
                field,
            }
        );
    }

    if (text.trim().length > maxLength) {
        throw new ValidationError(
            `${field} must not exceed ${maxLength} characters.`,
            {
                code: VALIDATION_ERROR_CODES.TOO_LONG_TEXT,
                field,
            }
        );
    }
};

/**
 * Validates id
 * @param {String} id 
 * @throws {ValidationError}
 */
const validateId = id => {
    const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    if (!uuidV4Regex.test(id)) {
        throw new ValidationError(
            'Invalid ID: expected a UUID generated by crypto.', 
            {
                code: VALIDATION_ERROR_CODES.INVALID_ID,
            }
        );
    }
};

/**
 * Validates title:
 * 1. Not empty
 * 2. Not too long
 * @param {String} text 
 * @throws {ValidationError}
 */
const validateTitle = title => validateText(title, 50, 'title');

/**
 * Validates description:
 * 1. Not empty
 * 2. Not too long
 * @param {String} text 
 * @throws {ValidationError}
 */
const validateDescription = description => validateText(description, 100, 'description');

/**
 * Validates due date:
 * 1. Valid date
 * 2. Not past date
 * @param {Date} dueDate 
 * @throws {ValidationError}
 */
const validateDueDate = dueDate => {
    if (!isValidDate(dueDate)) {
        throw new ValidationError(
            'Invalid date: expected a valid JavaScript Date object.',
            {
                code: VALIDATION_ERROR_CODES.INVALID_DATE,
            }
        );
    }

    if (!isFutureDate(dueDate)) {
        throw new ValidationError(
            'Invalid date: must be a future date.',
            {
                code: VALIDATION_ERROR_CODES.DATE_IN_PAST,
            }
        );
    }
};

/**
 * Validate priority
 * @param {import("../modules/constants").PriorityType} priority 
 * @throws {ValidationError}
 */
const validatePriority = priority => {
    if (!PRIORITY.isValid(priority)) {
        throw new ValidationError(
            "Invalid priority: expected 'low', 'medium', or 'high'.",
            {
                code: VALIDATION_ERROR_CODES.INVALID_PRIORITY,
            }
        );
    }
};

/**
 * Validates status
 * @param {import("../modules/constants").StatusType} status 
 * @throws {ValidationError}
 */
const validateStatus = status => {
    if (!STATUS.isValid(status)) {
        throw new ValidationError(
            "Invalid status: expected 'pending', 'in-progress', or 'completed'.",
            {
                code: VALIDATION_ERROR_CODES.INVALID_STATUS,
            }
        );
    }
};

/**
 * Validates name:
 * 1. Not empty
 * 2. Not too long
 * @param {String} text 
 * @throws {ValidationError}
 */
const validateName = name => validateText(name, 50, 'name');

const validatorsMap = {
    id: { type: String, fn: validateId },
    title: { type: String, fn: validateTitle },
    description: { type: String, fn: validateDescription },
    name: { type: String, fn: validateName },
    dueDate: { type: Date, fn: validateDueDate },
    priority: { type: String, fn: validatePriority },
    status: { type: String, fn: validateStatus },
};

/**
 * @param {any} property
 * @param {'id' | 'title' | 'description' | 'name' | 'dueDate' | 'priority' | 'status'} type
 * @throws {ValidationError}
 */
export const validate = (field, type) => {
    const validator = validatorsMap[type];
    if (!validator) {
        throw new Error(`Unknown field ${type}`);
    }
    validateType(field, validator.type, { field: type });
    validator.fn(field);
};

/**
 * Validates object
 * @param {Object} obj 
 * @throws {ValidationError}
 */
export const validateObject = (obj) => {
    for (const [key, value] of Object.entries(obj)) {
        if (validatorsMap[key]) {
            validate(value, key);
        }
    }
};

